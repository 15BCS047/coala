import asyncio
import concurrent.futures
import logging

import functools
import multiprocessing

from coalib.core import DependencyTracker


def get_cpu_count():
    try:
        return multiprocessing.cpu_count()
    except NotImplementedError:  # pragma: no cover
        # cpu_count is not implemented for some CPU architectures/OSes
        return 1


def schedule_bears(bears,
                   dependency_tracker,
                   event_loop,
                   executor):
    """
    Schedules the tasks of bears to the given executor and runs them on the
    given event loop.

    :param bears:
        A list of bear instances to be scheduled onto the process pool.
    :param dependency_tracker:
        The object that keeps track of dependencies.
    :param event_loop:
        The asyncio event loop to schedule bear tasks on.
    :param executor:
        The executor to which the bear tasks are scheduled.
    """
    blocking_tasks = {}

    for bear in bears:
        if bear not in dependency_tracker.dependency_dict:
            blocking_tasks[bear] = [
                event_loop.run_in_executor(executor,
                                           bear.execute_task,
                                           task[0],
                                           task[1])
                for task in bear.generate_tasks()]
            for task in blocking_tasks[bear]:
                task.add_done_callback(functools.partial(finish_task,
                                                         bear,
                                                         dependency_tracker,
                                                         blocking_tasks,
                                                         event_loop,
                                                         executor))


def finish_task(bear,
                dependency_tracker,
                blocking_tasks,
                event_loop,
                executor,
                task):
    """
    The callback for when a task of a bear completes. It is responsible for
    checking if the bear completed its execution and the handling of the
    result generated by the task. It also schedules new tasks if dependencies
    get resolved.

    :param bear:
        The bear that the task belongs to.
    :param dependency_tracker:
        The object that keeps track of dependencies.
    :param blocking_tasks:
        Dictionary that keeps track of the remaining tasks of each bear.
    :param event_loop:
        The ``asyncio`` event loop bear-tasks are scheduled on.
    :param executor:
        The executor to which the bear tasks are scheduled.
    :param task:
        The task that completed.
    """
    log = logging.getLogger('Consumer task')
    log.info(bear)
    # TODO Handle exceptions
    for result in task.result():
        log.info(result)
    blocking_tasks[bear].remove(task)
    if not blocking_tasks[bear]:
        resolved_bears = dependency_tracker.resolve(bear)
        if resolved_bears:
            schedule_bears(resolved_bears, dependency_tracker, event_loop,
                           blocking_tasks, executor)
        del blocking_tasks[bear]
    if not blocking_tasks:
        event_loop.stop()


# TODO This is only relevant for instantiating bears.
def load_files(filenames):
    """
    Loads all files and arranges them inside a file-dictionary, where the keys
    are the filenames and the values the contents of the file (line-split
    including return characters).

    Files that fail to load are ignored.

    :param filenames: The names of the files to load.
    :return:          The file-dictionary.
    """
    file_dict = {}
    for filename in filenames:
        try:
            with open(filename, 'r', encoding='utf-8') as fl:
                file_dict[filename] = tuple(fl.readlines())
        except UnicodeDecodeError:
            logging.warning(
                "Failed to read file '{}'. It seems to contain non-unicode "
                'characters. Leaving it out.'.format(filename))
        except OSError as ex:  # pragma: no cover
            logging.warning(
                "Failed to read file '{}' because of an unknown error. "
                'Leaving it out.'.format(filename), exc_info=ex)

    logging.debug('Following files loaded:\n' + '\n'.join(file_dict.keys()))

    return file_dict


def run(bears):
    """
    Runs a coala session.

    :param bears: The bear instances to run.
    """
    # TODO Maybe try to allow to exchange executor, especially to allow
    # TODO   distributed computation.

    # Set up event loop and executor.
    event_loop = asyncio.SelectorEventLoop()
    executor = concurrent.futures.ProcessPoolExecutor(
        max_workers=get_cpu_count())

    # Initialize dependency tracking.
    dependency_tracker = DependencyTracker()
    dependency_tracker.add_bear_dependencies(bears)

    # Let's go.
    schedule_bears(bears, dependency_tracker, event_loop, executor)
    try:
        event_loop.run_forever()
    finally:
        event_loop.close()
