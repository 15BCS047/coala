import asyncio
import concurrent.futures
import logging
import sys
from coalib.collecting.Collectors import collect_files
from Fileproxy import FileProxy
from TestBear import TestBear
from AnotherBear import AnotherBear
from Dependencies import Dependencies
from DependentBear import DependentBear
from AnotherDependentBear import AnotherDependentBear
import functools
import multiprocessing


def get_cpu_count():
    try:
        return multiprocessing.cpu_count()
    # cpu_count is not implemented for some CPU architectures/OSes
    except NotImplementedError:  # pragma: no cover
        return 2


def schedule_bears(bears,
                   dep_resolver,
                   event_loop,
                   blocking_tasks,
                   executor):
    """
    Schedules the tasks of bears to the process pool and run the event loop to
    complete those tasks.

    :param bears:          A list of bears to be scheduled onto the process
                           pool.
    :param dep_resolver:   The object that keeps track of dependencies.
    :param event_loop:     The asyncio event loop.
    :param blocking_tasks: Dictionary that keeps track of the remaining tasks
                           of each bear.
    :param executor:       The process pool to which the bear tasks are
                           scheduled.
    """
    for bear in bears:
        if bear not in dep_resolver.dependency_dict:
            blocking_tasks[bear] = [
                event_loop.run_in_executor(executor,
                                           bear.execute_task,
                                           task[0],
                                           task[1])
                for task in bear.generate_tasks()]
            for task in blocking_tasks[bear]:
                task.add_done_callback(functools.partial(finish_task,
                                                         bear,
                                                         dep_resolver,
                                                         blocking_tasks,
                                                         event_loop,
                                                         executor))


def finish_task(bear,
                dep_resolver,
                blocking_tasks,
                event_loop,
                executor,
                task):
    """
    The callback for when a task of a bear completes. It is responsible for
    checking if the bear completed its execution and the handling of the
    result generated by the task.

    :param bear:           The bear that the task belongs to.
    :param dep_resolver:   The object that keeps track of dependencies.
    :param blocking_tasks: Dictionary that keeps track of the remaining tasks
                           of each bear.
    :param event_loop:     The asyncio event loop.
    :param executor:       The process pool to which the bear tasks are
                           scheduled.
    :param task:           The task that completed.
    """
    log = logging.getLogger('Consumer task')
    log.info(bear)
    # TODO Handle exceptions
    for result in task.result():
        log.info(result)
    blocking_tasks[bear].remove(task)
    if not blocking_tasks[bear]:
        resolved_bears = dep_resolver.resolve(bear)
        if resolved_bears:
            schedule_bears(resolved_bears,
                           dep_resolver,
                           event_loop,
                           blocking_tasks,
                           executor)
        del blocking_tasks[bear]
    if not blocking_tasks:
        event_loop.stop()


def load_files(filenames):
    # TODO Populate file_dict here
    pass


def run(bears,
        filenames,
        executor=concurrent.futures.ProcessPoolExecutor(
            max_workers=get_cpu_count())):

    event_loop = asyncio.SelectorEventLoop()

    file_dict = load_files(filenames)

    blocking_tasks = {}
    dep_resolver = Dependencies()
    dep_resolver.add_bear_dependencies(bears)

    # Make blocking_tasks = {} default in schedule_bears

    schedule_bears(bears,
                   dep_resolver,
                   event_loop,
                   blocking_tasks,
                   executor)
    try:
        event_loop.run_forever()
    finally:
        event_loop.close()
